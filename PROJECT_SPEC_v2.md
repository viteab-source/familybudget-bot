# FamilyBudget Bot — ТЗ и чек-лист v2.0

Версия: v2.0
Дата: 2025-12-11

---

## 0. Репозиторий и артефакты

**GitHub:**
`https://github.com/viteab-source/familybudget-bot.git`

**Основная структура:**

* `backend/app` — FastAPI + SQLAlchemy backend

  * модели БД, схемы (pydantic), API-роуты, вспомогательные функции, интеграция с YandexGPT
* `bot` — Telegram-бот на aiogram 3

  * хендлеры команд и сообщений
  * сервисы для общения с backend
  * логика форматирования сообщений
* `PROJECT_CONTEXT.txt` — текстовый файл с кратким контекстом проекта

  * **обязателен к прочтению любым ИИ перед предложением изменений**

---

## 1. Что мы вообще делаем

**Продукт:** семейный финансовый ассистент в Телеграме.
Формат — бот, которому пишешь как живому человеку:

> «Перекрёсток, продукты 2435 вчера»

Дальше всё делает ИИ:

* вытаскивает сумму и валюту;
* определяет дату (сегодня / вчера / конкретная дата в тексте);
* подбирает категорию;
* определяет магазин/сервис (merchant);
* создаёт транзакцию в Postgres.

**Основные возможности:**

* учёт расходов и доходов для семьи;
* бюджеты по категориям (например: «Продукты до 30 000 в месяц»);
* отчёты по семье, по людям, по магазинам;
* напоминания («Коммуналка 8000 раз в месяц»), из которых в один клик создаётся расход и сдвигается следующее напоминание;
* локальная «память» бота по категориям (бот учится на исправлениях пользователя).

Вся логика и данные — в нашем backend + PostgreSQL.
Google Sheets сейчас **опциональны**, только через экспорт CSV.

---

## 2. Архитектура и стек

### 2.1. Технологии

* Язык: **Python 3**
* Бот: **aiogram 3**
* Backend API: **FastAPI**
* БД: **PostgreSQL** + **SQLAlchemy**
* ИИ:

  * **YandexGPT JSON API** — разбор текстов расходов/доходов
  * **Yandex SpeechKit STT** — распознавание голосовых сообщений в текст
* Конфигурация:

  * `.env` (BOT_TOKEN, API_BASE_URL, DB_HOST, DB_NAME, DB_USER, DB_PASSWORD, YANDEX_API_KEY и т.д.)

### 2.2. Общая схема

1. Пользователь пишет в бота текст / отправляет голос / вводит данные руками.
2. Бот:

   * для голоса: через STT получает текст;
   * отправляет текст и метаданные в backend (`/api/transactions/parse-and-create` или `/api/transactions`).
3. Backend:

   * через YandexGPT парсит текст;
   * подтягивает/создаёт категории, merchant;
   * учитывает CategoryOverride (локальную память);
   * создаёт Transaction в БД;
   * считает бюджетную статистику.
4. Backend возвращает в бот:

   * данные транзакции;
   * бюджетную информацию;
   * (опционально) подсказки по категориям.
5. Бот показывает пользователю оформленное сообщение с inline-кнопками для категории (умные категории v1).

---

## 3. Данные и модели БД

(Названия полей могут слегка отличаться, точная схема — в `backend/app/models.py`.)

### 3.1. Основные сущности

**User**

* `id`
* `telegram_id` (уникальный)
* `name`

**Household**

* `id`
* `name`
* `currency` (например, `RUB`)
* `privacy_mode` (см. планы по приватности ниже)
* доп. сервисные поля

**HouseholdMember**

* `id`
* `user_id` → User
* `household_id` → Household
* `role` — `"owner" | "admin" | "member"`

**Category** (Категории 2.0)

* `id`
* `household_id` → Household
* `name`
* `parent_id` → Category (для дерева/иерархии)
* `sort_order` (для красивого вывода)

**Transaction**

* `id`
* `household_id` → Household
* `user_id` → User
* `amount`
* `currency` (обычно как у Household)
* `kind` — `"expense"` / `"income"`
* `description`
* `category` — строковое имя (legacy)
* `category_id` → Category (новый основной способ)
* `merchant` — магазин / сервис (строка)
* `date` — дата операции
* `created_at` — фактическая дата создания записи

**CategoryBudget**

* `id`
* `household_id` → Household
* `category_id` → Category
* `period_month` — `"YYYY-MM"`
* `limit_amount`

**Reminder**

* `id`
* `household_id` → Household
* `user_id` → User (кто создал / ответственный)
* `title`
* `amount`
* `currency`
* `interval_days`
* `next_run_at`
* `is_active`

**HouseholdInvite**

* `id`
* `household_id` → Household
* `code` — короткий инвайт-код
* `expires_at`

### 3.2. Локальная память категорий

**CategoryFeedback**

* Лог того, как пользователь исправлял категорию.
* Пример полей:

  * `id`
  * `household_id`
  * `user_id`
  * `transaction_id` (опционально)
  * `old_category_id` / `old_category_name`
  * `new_category_id` / `new_category_name`
  * `source` (ai_suggestion / manual / typo_suggestion и т.п.)
  * `message_text` — исходный текст операции (если есть)
  * `created_at`

**CategoryOverride**

* Локальная «память» вида: «для такого текста / такого шаблона теперь по умолчанию вот эта категория».
* Используется в parse-and-create: если пользователь несколько раз исправлял категорию для похожего текста, дальше выбирается сразу правильная категория.

(Точные поля смотреть в коде.)

---

## 4. Что уже сделано (функционал)

### 4.1. Пользователи и семьи

**Backend:**

* Автоматическое создание User и Household по `telegram_id`:

  * если user/household нет — создаём;
  * если есть — подтягиваем.
* `/me` — информация о пользователе и его семье (user_id, household_id, роль и т.п.).
* `/household` — информация о семье + участники.
* `/household/invite` — создание инвайта (короткий код).
* `/household/join` — присоединение к семье по коду.
* `/household/rename` — переименование семьи (owner/admin).
* `/household/leave`:

  * обычный участник — просто выходит;
  * owner с другими участниками — **не может** выйти;
  * если owner один — при выходе семья и membership удаляются.

**Бот:**

* `/start`, `/help`
* `/setname` — задать/поменять имя.
* `/me` — профиль.
* `/family` — инфо о семье.
* `/family_invite` — код приглашения.
* `/family_join КОД` — присоединиться.
* `/family_rename` — переименовать семью.
* `/family_leave` — выйти (с подтверждением).

---

### 4.2. Категории 2.0

**Backend:**

* Таблица `Category` с `household_id`, `name`, `parent_id`, `sort_order`.
* `/categories`:

  * возвращает список категорий семьи;
  * подтягивает старые строковые `Transaction.category`, создаёт недостающие категории (миграция «на лету»).
* `/categories` (POST) — создать категорию (с защитой от дублей).
* `/categories/rename` — переименовать категорию + обновить `Transaction.category`.
* `/categories/merge` — объединить две категории:

  * все транзакции переводятся на целевую категорию;
  * исходная категория удаляется.
* `/categories/delete`:

  * удаляет категорию, если нет связанных транзакций;
  * если транзакции есть — отдаёт ошибку и предлагает использовать merge.
* `/categories/feedback`:

  * принимает и сохраняет записи `CategoryFeedback` по исправлениям категорий.

**Бот:**

* `/categories` — список категорий.
* `/cat_add` — добавить категорию.
* `/cat_rename` — переименовать.
* `/cat_merge` — объединить.
* `/cat_delete` — удалить (перед удалением проверяет, что нет транзакций).

---

### 4.3. Транзакции, ИИ и голос

**Backend:**

* `/transactions` (POST):

  * создаёт операцию (расход/доход), связывает с household и user;
  * прикрепляет бюджетную информацию (limit, spent, percent).
* `/transactions` (GET) — список транзакций с фильтрами по дате и т.п.
* `/transactions/last` — последняя транзакция конкретного пользователя в семье.
* `/transactions/delete-last` — удалить последнюю.
* `/transactions/edit-last` — изменить сумму/описание последней.

  * при изменении описания — пересчитывается `merchant`.
* `/transactions/set-category-last` — поменять категорию последней транзакции.

  * логирует `CategoryFeedback`.
* `/transactions/export/csv` — выгрузка всех транзакций в CSV (Excel/Sheets).

**ИИ-разбор `/transactions/parse-and-create`:**

* Получает текст пользователя (например: `«Перекрёсток продукты 2435 вчера»`).
* Вызывает `parse_text_to_transaction` из `ai.py` (YandexGPT).

  * На выходе:

    * сумма;
    * валюта;
    * дата;
    * категория (строкой);
    * описание.
* Backend:

  * нормализует сумму и дату;
  * ищет/создаёт категорию;
  * определяет `merchant` по описанию и исходному тексту (helper `extract_merchant_from_text(...)`);
  * применяет `CategoryOverride` (если есть подходящее правило);
  * создаёт транзакцию (`kind="expense"` по умолчанию);
  * считает бюджет и прикладывает его в ответе;
  * возвращает данные транзакции и бюджетную информацию.

**Merchant:**

* `Transaction.merchant` — новое поле.
* При создании и редактировании:

  * merchant вытаскивается через `extract_merchant_from_text(...)`;
  * при `/transactions/edit-last` с изменением описания — пересчитывается.

**Бот:**

* `/add` — добавить расход вручную.
* `/income` — добавить доход.
* `/aiadd` — добавить расход через ИИ (текст).
* Любой произвольный текст (который не команда):

  * обрабатывается как запрос на создание расхода через ИИ.
* Голосовые сообщения:

  * бот скачивает файл;
  * отправляет в Yandex SpeechKit STT;
  * полученный текст отправляет в `/transactions/parse-and-create`;
  * дальше всё как для текстового ввода.
* Форматирование транзакций:

  * единая функция `format_transaction(...)`, которая:

    * красиво выводит сумму (с разделителями тысяч);
    * выводит категорию;
    * выводит merchant;
    * выводит дату операции.

**“Умные категории v1” (бот):**

* После любого ИИ-расхода (`/aiadd`, текст, голос):

  * бот показывает inline-кнопки с категориями:

    * текущая категория (с ✅);
    * ещё 2–3 категории из набора существующих.
* При нажатии:

  * вызывается `/transactions/set-category-last`;
  * обновляется категория последней транзакции;
  * inline-клавиатура удаляется;
  * пользователю отправляется подтверждение.
* Выбор пользователя логируется через `/categories/feedback` (`CategoryFeedback`).

---

### 4.4. Бюджеты

**Backend:**

* Таблица `CategoryBudget` (`category_id + period_month + limit_amount`).
* `/budget/set` — задать/обновить лимит для категории на текущий месяц.
* `/budget/status`:

  * по каждой категории считает:

    * `limit`;
    * `spent` за период;
    * `%` от лимита.

**Бот:**

* `/budget_set` — установить лимит для категории.
* `/budget_status` — показать все лимиты и статус (включая проценты).

---

### 4.5. Напоминания

**Backend:**

* `Reminder`:

  * `title`, `amount`, `currency`
  * `interval_days`, `next_run_at`, `is_active`
  * `household_id`, `user_id`
* `/reminders` (POST) — создать напоминание.
* `/reminders` (GET) — список напоминаний семьи (есть фильтр `only_active`).
* `/reminders/due-today` — напоминания, которые нужно показать сегодня.
* `/reminders/{id}/mark-paid`:

  * создаёт транзакцию-расход, если есть сумма:

    * household и user берутся из напоминания;
    * категория создаётся по `title`, если её ещё нет;
    * `kind="expense"`, дата = текущая;
  * если `interval_days` не задан:

    * делает напоминание неактивным;
  * если задан:

    * сдвигает `next_run_at` на интервал.

**Бот:**

* `/remind_add` — создать напоминание.
* `/reminders` — список.
* `/remind_today` — напоминания на сегодня.
* `/remind_pay` — оплачивает (создаёт расход и сдвигает/отключает напоминание).

---

### 4.6. Отчёты и экспорт

**Backend:**

* `/report/summary`

  * Параметры:

    * `days`
    * `telegram_id`, `user_id`
  * Считает:

    * `total_amount` — сумма расходов;
    * `by_category` — список `{category, amount}`.
  * Если указан `user_id` — фильтр по конкретному пользователю.

* `/report/balance`

  * Параметры:

    * `days`
    * `telegram_id`, `user_id`
  * Считает:

    * `incomes_total`;
    * `expenses_total`;
    * `net = доходы - расходы`.
  * Если `user_id` есть — тоже фильтр по пользователю.

* `/report/members`

  * Расходы по участникам семьи: `{member_name, amount}`.

* `/report/shops`

  * Использует `Transaction.merchant` (если нет — пытается найти в тексте).
  * Считает сумму по каждому магазину.

* `/transactions/export/csv`

  * CSV-выгрузка транзакций (для Excel/Sheets).

**Бот:**

* `/report [N]` — общий отчёт по семье за N дней (по умолчанию 14).
* `/report_me [N]` — расходы только текущего пользователя.
* `/report_members [N]` — расходы по людям.
* `/balance [N]` — общий баланс семьи.
* `/balance_me [N]` — баланс только по операциям пользователя.
* `/report_shops [N]` — топ магазинов.
* `/export` — выгрузка (если привязана к backend-эндпоинту).

Все суммы в отчётах форматируются:

* `123456.78` → `123 457 RUB`.

---

### 4.7. Рефакторинг и структура кода

**Backend:**

* Разнесён на модули (примерная структура):

  * `api/users.py`
  * `api/households.py`
  * `api/categories.py`
  * `api/transactions.py`
  * `api/budgets.py`
  * `api/reports.py`
  * `api/reminders.py`
* Вынесено вспомогательное:

  * `deps.py` — `get_db()` и общие зависимости.
  * `utils.py` — даты, merchant, форматирование, вероятно `find_similar_category(...)`.
  * `ai.py` — обёртки над YandexGPT.
* Логирование: настроены базовые логгеры.

**Бот:**

* Разбит на модули:

  * `handlers/base.py`
  * `handlers/user_family.py`
  * `handlers/transactions.py`
  * `handlers/categories.py`
  * `handlers/budgets.py`
  * `handlers/reports.py`
  * `handlers/reminders.py`
* Есть сервисный слой:

  * `services/api_client.py` — единый клиент для общения с backend.
* Форматирование (например, `format_transaction(...)`) вынесено отдельно.

---

## 5. Что ещё предстоит сделать (чек-лист)

Ниже — сводный список задач.
Пометка `[CORE]` — приоритетно, `[LATER]` — можно позже.

### A. Категории и опечатки [CORE]

**Цель:** защита от опечаток и дубликатов категорий, без ломания UX.

1. На backend уже есть функция `find_similar_category(db, household_id, raw_name)` (на базе `difflib`).
2. Нужно встроить её:

   * в логику создания/подбора категорий при создании транзакции (`create_transaction` / parse-and-create);
   * в `/transactions/set-category-last` (когда пользователь меняет категорию руками).
3. Нужна политика использования similarity-score. Предлагаемый вариант:

   * `similarity >= 0.95` → **автоисправление**:

     * сразу маппим на найденную категорию;
     * `needs_confirmation = false`;
     * логируем в `CategoryFeedback` с `source="auto_typo_fix"`.
   * `0.80 <= similarity < 0.95` → **нужна явная проверка у пользователя**:

     * backend возвращает:

       * `suggested_category_id`, `suggested_category_name`;
       * `needs_confirmation = true`;
     * бот показывает запрос с кнопками (см. блок B).
   * `similarity < 0.80` → считаем, что это новая категория, **без подсказок**.

**Ожидаемый результат:**

* Backend-ответы по действиям с категориями умеют возвращать:

  * `applied_category_id`, `applied_category_name`;
  * `suggested_category_id`, `suggested_category_name`;
  * `needs_confirmation: bool`.

---

### B. UX подтверждения исправления категории в боте [CORE]

**Цель:** если backend видит, что категория похожа на существующую, но нужна проверка, бот должен красиво спросить.

1. Протокол между backend и ботом:

   * если backend вернул `needs_confirmation = true` и `suggested_category`:

     * бот должен отобразить:

       > «Похоже, ты имел в виду „Такси“, а не „Такиси“. Как сохранить?»

     * inline-кнопки:

       * `Такси` (принять подсказку)
       * `Оставить "Такиси"` (оставить как пользователь ввёл)

2. Тех. детали (предложение):

   * Callback-данные:

     * `cat_fix_yes:<transaction_id>` — принять подсказанную категорию;
     * `cat_fix_no:<transaction_id>` — оставить как есть.
   * При `cat_fix_yes`:

     * вызывается `/transactions/set-category-last` или отдельный эндпоинт по `transaction_id` + `category_id`;
     * создаётся запись в `CategoryFeedback`:

       * `old_category`, `new_category`;
       * `source="typo_suggestion_accepted"`;
       * `message_text` / `raw_text`, если есть.
   * При `cat_fix_no`:

     * категория не меняется;
     * можно залогировать отказ (`source="typo_suggestion_rejected"`), чтобы в будущем не спамить похожими подсказками.

3. Текст для пользователя — **только на русском**.

---

### C. Нормализация и чистка категорий [CORE]

**Цель:** избавиться от дублей категорий и грязи, не ломая отчёты.

1. Определить функцию нормализации имени категории:

   * привести к одному регистру (например, нижний);
   * обрезать пробелы в начале/конце;
   * заменить множественные пробелы одним;
   * по возможности убрать лишние спецсимволы на концах.

2. Миграция/скрипт чистки (однократный, но **идемпотентный**):

   * Шаг 1: найти дубли категорий в рамках одного `household_id`, которые после нормализации совпадают.
   * Шаг 2: выбрать «главную» категорию (например, самую старую или ту, у которой больше всего транзакций).
   * Шаг 3: для дублей:

     * обновить все `transactions.category_id` → на `main_category_id`;
     * обновить все связанные записи (budget, overrides, feedback), где хранятся ссылки на старую категорию;
     * после переноса удалить дубли.
   * Шаг 4: для явно кривых опечаток (`такиси` → `Такси`) можно использовать `find_similar_category`:

     * но auto-слияние делать только при высокой similarity и **без** конфликта с другими категориями (`Такси` vs `Такси Яндекс` — не сливать автоматически).

3. Отдельный CLI-скрипт или alembic-миграция, которую можно запустить вручную.

---

### D. Отчёты — фильтры по категориям [CORE]

1. Backend:

   * добавить параметр `category_id` (или `category`) в:

     * `/report/summary`
     * `/report/members`
     * `/report/balance`
   * внутри фильтровать по указанной категории:

     * либо по `category_id`;
     * либо по всем транзакциям, которые ссылаются на эту категорию.

2. Бот:

   * добавить команды:

     * `/report_cat <Категория> [дней]` — отчёт по одной категории;
     * `/report_members_cat <Категория> [дней]` — кто сколько потратил в категории;
     * `/balance_cat <Категория> [дней]` — доходы/расходы/итог по категории.
   * Нужен удобный парсинг названия категории:

     * разрешать пробелы;
     * быть устойчивым к регистру.

---

### E. “Умные категории v2” [CORE]

**Цель:** использовать ИИ не только для одной категории, но и для набора кандидатов + учиться на фидбэке.

1. Backend / ИИ:

   * расширить `parse_text_to_transaction` и `/transactions/parse-and-create`, чтобы:

     * YandexGPT возвращал `candidate_categories` (например, top-3) с вероятностями;
     * backend отдавал их в ответе боту.

2. Бот:

   * вместо того, чтобы брать 2–3 случайные категории из общего списка:

     * показывать именно `candidate_categories` от ИИ + текущий выбор.
   * При выборе:

     * логировать в `CategoryFeedback`:

       * `ai_initial_category`;
       * `final_category`;
       * `candidate_set`;
       * `message_text`.

3. На backend:

   * на основе `CategoryFeedback` строить алиасы:

     * слова/фразы → категория;
   * учитывать алиасы в `parse_text_to_transaction` / `CategoryOverride`, чтобы следующие похожие сообщения сразу попадали в нужную категорию.

---

### F. Голос и чеки [LATER]

#### F1. Голос (дотюнинг) [CORE/LATER]

* Сейчас цепочка «voice → STT → parse-and-create → транзакция» уже работает.
* Нужно:

  * убедиться, что для голосовых сообщений всегда включается `send_ai_category_suggestions` (умные категории v1/v2);
  * добавить логирование ошибок STT и ограничений по длительности/качеству;
  * продумать юзерский текст в случае ошибок распознавания.

#### F2. Чеки / маркетплейсы [LATER]

* Спроектировать модели:

  * `Receipt`, `ReceiptItem`, `File` или аналог.
* Реализовать:

  * загрузку чеков (фото / QR / PDF):

    * либо через интеграцию с ФНС/ОФД;
    * либо через OCR + ИИ-разбор позиций.
  * разнос по категориям (по товарам/позициям).
* В отчётах:

  * возможность смотреть расходы по товарам / магазинам с детализацией.

---

### G. WebApp / Mini-app [LATER]

* Авторизация через Telegram `initData`.
* Экраны:

  * Dashboard (общий обзор по семье);
  * Transactions (список, фильтры, редактирование);
  * Categories & Budgets;
  * Reminders;
  * Settings.
* Backend:

  * при необходимости расширить API для пагинации и фильтрации.

---

### H. Приватность и роли [LATER]

* В `Household.privacy_mode` реализовать режимы:

  * `OPEN` — все видят всё;
  * `AGGREGATED` — по людям только агрегированные данные, без детализации транзакций;
  * `ADMIN_ONLY` — только owner/admin видят детальные транзакции и отчёты.
* В отчётах и списках:

  * применять правила в зависимости от `privacy_mode`.

---

### I. Напоминания 2.0 [LATER]

* Более гибкие расписания:

  * раз в месяц в конкретную дату;
  * раз в неделю по дням недели;
  * по будням и т.п.
* Логирование:

  * `ReminderLog` — когда сработало, кто оплатил, какая сумма.
* Возможность назначить «ответственного» за напоминание (конкретный член семьи).

---

### J. Тарифы и лимиты (Free / Pro / Business) [LATER]

* Определить модель:

  * поле `plan` у `User` или `Household`.
* Ограничения Free:

  * лимит транзакций в день/месяц;
  * лимит напоминаний;
  * без WebApp / Google Sheets / чеков.
* Pro:

  * полный функционал для семьи.
* Business:

  * несколько домохозяйств;
  * расширенные отчёты;
  * экспорт для бухгалтерии.

---

### K. Инфра, тесты и CI/CD [LATER]

* `docker-compose`:

  * `api` (backend)
  * `bot`
  * `postgres`
  * (опционально) `worker` для фоновых задач.
* Логи:

  * раздельные логгеры для API, бота, ИИ, STT.
* Тесты:

  * простые автотесты для ключевых эндпоинтов backend (transactions, categories, reports).
* CI/CD:

  * GitHub Actions:

    * запуск тестов;
    * линтер;
    * (по возможности) деплой.

---

## 6. Правила работы с проектом и ИИ-помощниками

Эта секция для любого ИИ, который будет помогать с разработкой.

1. **Всегда сначала читать `PROJECT_CONTEXT.txt`** и по возможности свежий код в репозитории.

2. Не придумывать новые сущности/поля, пока это явно не согласовано — опираться на реальную схему моделей.

3. Все тексты, которые видит пользователь в Телеграме, должны быть **на русском**.

4. При предложении изменений в коде:

   * указывать **точный путь файла**, например:

     * `backend/app/api/transactions.py`
     * `bot/handlers/categories.py`
   * приводить **полный обновлённый код функции / класса / Pydantic-схемы**, а не кусок.
   * если изменения большие — можно предложить целый файл целиком.

5. Формат предложенного git-коммита:

   * `component: краткое описание`
   * Примеры:

     * `backend: use similar category suggestions in create_transaction`
     * `bot: ask user to confirm category correction`
     * `infra: add docker-compose for api+bot+postgres`

6. При необходимости новых эндпоинтов/таблиц:

   * сначала описать их в тексте (модель, поля, формат запрос/ответ);
   * только после этого предлагать код.

7. Все изменения по сложной логике категорий/опечаток должны:

   * логировать фидбэк пользователя в `CategoryFeedback`;
   * не ломать существующие отчёты и бюджеты.

---

## 7. Как запустить проект локально (кратко)

1. Клонировать репозиторий:

   ```bash
   git clone https://github.com/viteab-source/familybudget-bot.git
   cd familybudget-bot
   ```

2. Создать и активировать виртуальное окружение, установить зависимости (см. `requirements.txt`).

3. Настроить `.env`:

   * `BOT_TOKEN=...`
   * `API_BASE_URL=http://127.0.0.1:8000`
   * `DATABASE_URL=postgresql+psycopg2://...`
   * `YANDEX_API_KEY=...`
   * прочие параметры.

4. Запустить backend:

   ```bash
   uvicorn backend.app.main:app --reload
   ```

5. Запустить бота:

   ```bash
   python -m bot.bot
   ```

6. Проверить в логах:

   * backend слушает `/api/...`;
   * бот подключился и «Ждём сообщения...».

---

Этот документ — актуальное ТЗ и чек-лист v2.0.
Его можно хранить в репозитории (например, `PROJECT_SPEC_v2.md`) и использовать как единый входной контекст для новых диалогов с ИИ и разработчиками.

